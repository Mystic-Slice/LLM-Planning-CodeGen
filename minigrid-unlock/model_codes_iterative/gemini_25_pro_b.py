import collections
import copy # Import the copy module for deep copying the grid

# --- Helper Functions ---
def find_object_coordinates(grid, object_type):
    """Finds the (row, col) of the first occurrence of object_type."""
    for r, row in enumerate(grid):
        for c, cell in enumerate(row):
            if cell == object_type:
                return (r, c)
    return None # Should not happen in valid inputs as per description

def turn_left(direction):
    """Calculates the new direction after turning left."""
    if direction == "UP": return "LEFT"
    if direction == "LEFT": return "DOWN"
    if direction == "DOWN": return "RIGHT"
    if direction == "RIGHT": return "UP"

def turn_right(direction):
    """Calculates the new direction after turning right."""
    if direction == "UP": return "RIGHT"
    if direction == "RIGHT": return "DOWN"
    if direction == "DOWN": return "LEFT"
    if direction == "LEFT": return "UP"

def calculate_forward_pos(pos, direction):
    """Calculates the coordinates of the cell in front."""
    r, c = pos
    if direction == "UP": return (r - 1, c)
    if direction == "DOWN": return (r + 1, c)
    if direction == "LEFT": return (r, c - 1)
    if direction == "RIGHT": return (r, c + 1)
    return pos # Should not happen

def is_valid_move(grid, pos):
    """
    Checks if moving INTO the cell at pos is valid.
    Movement is invalid if going out of bounds or INTO a WALL, KEY, or DOOR.
    """
    height = len(grid)
    width = len(grid[0]) if height > 0 else 0
    r, c = pos
    # Check bounds
    if not (0 <= r < height and 0 <= c < width):
        return False
    # Check content - cannot move INTO a cell containing these objects
    cell_content = grid[r][c]
    # *** MODIFICATION START ***
    # Treat KEY and DOOR as obstacles for movement, similar to WALL.
    if cell_content in ["WALL", "KEY", "DOOR"]:
        return False
    # *** MODIFICATION END ***
    # Other objects (like AGENT's starting position if needed) or empty strings "" are okay to move into.
    return True

def apply_action_to_state(pos, direction, action):
    """Applies an action and returns the new (pos, direction) state."""
    if action == "LEFT":
        return pos, turn_left(direction)
    elif action == "RIGHT":
        return pos, turn_right(direction)
    elif action == "MOVE":
        new_pos = calculate_forward_pos(pos, direction)
        # We assume the path generated by BFS only contains valid moves
        # (based on the grid state used for that specific BFS call).
        return new_pos, direction
    else: # PICKUP, UNLOCK, DROP don't change position/direction
        return pos, direction

def find_path_to_adjacent(grid, start_pos, start_dir, target_pos):
    """
    Uses BFS to find the shortest action sequence (LEFT, RIGHT, MOVE)
    to reach a state adjacent to target_pos, facing target_pos.
    Operates on the provided grid state.

    Args:
        grid (list[list[str]]): The grid state to use for pathfinding.
        start_pos (tuple): Starting (row, col) of the agent.
        start_dir (str): Starting direction of the agent.
        target_pos (tuple): The (row, col) of the target object (KEY or DOOR).

    Returns:
        list: A list of actions, or None if no path found.
    """
    height = len(grid)
    width = len(grid[0]) if height > 0 else 0
    queue = collections.deque()
    # State: ((row, col), direction)
    # Queue item: ( state, path_list )
    start_state = (start_pos, start_dir)
    queue.append((start_state, []))
    # Visited: set of ((row, col), direction) tuples
    visited = {start_state}

    while queue:
        current_state, current_path = queue.popleft()
        current_pos, current_dir = current_state

        # --- Goal Check ---
        # Is the cell directly in front of the agent the target cell?
        pos_in_front = calculate_forward_pos(current_pos, current_dir)
        if pos_in_front == target_pos:
            # Check if agent is actually adjacent (should be implied by pos_in_front)
            # We don't need an explicit adjacency check here because reaching this state
            # means the agent is at current_pos facing towards target_pos.
            return current_path # Found the path

        # --- Explore Neighbors (Actions) ---
        possible_actions = ["LEFT", "RIGHT", "MOVE"]
        for action in possible_actions:
            next_pos = current_pos
            next_dir = current_dir
            valid_action = True

            if action == "LEFT":
                next_dir = turn_left(current_dir)
            elif action == "RIGHT":
                next_dir = turn_right(current_dir)
            elif action == "MOVE":
                # Calculate where the move would land
                move_target_pos = calculate_forward_pos(current_pos, current_dir)
                # Check if that *target cell* is valid to move *into* using the updated is_valid_move
                if is_valid_move(grid, move_target_pos):
                    next_pos = move_target_pos
                else:
                    valid_action = False # Cannot move into the cell in front

            if valid_action:
                next_state = (next_pos, next_dir)
                if next_state not in visited:
                    visited.add(next_state)
                    next_path = current_path + [action]
                    queue.append((next_state, next_path))

    return None # No path found

# --- Main Solver Function ---
def solve(grid, start_direction):
    """
    Calculates the sequence of actions to find the key and unlock the door.
    Args:
        grid (list[list[str]]): The initial 2D grid environment.
        start_direction (str): The agent's starting direction.
    Returns:
        list[str]: The sequence of actions, or None if no solution found.
    """
    agent_pos = find_object_coordinates(grid, "AGENT")
    key_pos = find_object_coordinates(grid, "KEY")
    door_pos = find_object_coordinates(grid, "DOOR")

    if not agent_pos or not key_pos or not door_pos:
        return None # Invalid setup

    agent_dir = start_direction
    action_sequence = []

    # 1. Phase 1: Go to the KEY and PICKUP
    #    Use the ORIGINAL grid, where KEY is an obstacle for movement.
    # print(f"Phase 1: Finding path from {agent_pos} facing {agent_dir} to adjacent of KEY {key_pos}")
    path_to_key_actions = find_path_to_adjacent(grid, agent_pos, agent_dir, key_pos)

    if path_to_key_actions is None:
        # print(f"Error: Cannot find path to Key at {key_pos}")
        return None

    # Execute path to Key
    for action in path_to_key_actions:
        action_sequence.append(action)
        agent_pos, agent_dir = apply_action_to_state(agent_pos, agent_dir, action)
        # print(f"  Action: {action}, New State: pos={agent_pos}, dir={agent_dir}") # Debug

    # Now adjacent to the key, facing it. Pick it up.
    action_sequence.append("PICKUP")
    # print(f"Picked up KEY. Current state: pos={agent_pos}, dir={agent_dir}")

    # 2. Phase 2: Go to the DOOR (holding KEY) and UNLOCK
    #    Use a MODIFIED grid where the KEY's location is now empty "".
    # *** MODIFICATION START ***
    # Create a deep copy of the grid to represent the state after pickup
    grid_after_pickup = copy.deepcopy(grid)
    # grid_after_pickup = [row[:] for row in grid] # Alternative deep copy

    # Make the key's original position empty in the copied grid
    kr, kc = key_pos
    # Basic bounds check before modifying grid copy
    if 0 <= kr < len(grid_after_pickup) and 0 <= kc < len(grid_after_pickup[0]):
         if grid_after_pickup[kr][kc] == "KEY": # Sanity check
            grid_after_pickup[kr][kc] = "" # Key's cell is now empty and traversable

    # print(f"Phase 2: Finding path from {agent_pos} facing {agent_dir} to adjacent of DOOR {door_pos} using grid after pickup")
    # Find path using the grid state *after* the key was picked up
    path_to_door_actions = find_path_to_adjacent(grid_after_pickup, agent_pos, agent_dir, door_pos)
    # *** MODIFICATION END ***

    if path_to_door_actions is None:
        # print(f"Error: Cannot find path to Door at {door_pos} while holding KEY")
        return None

    # Execute path to Door
    for action in path_to_door_actions:
        action_sequence.append(action)
        agent_pos, agent_dir = apply_action_to_state(agent_pos, agent_dir, action)
        # print(f"  Action: {action}, New State: pos={agent_pos}, dir={agent_dir}") # Debug

    # Now adjacent to the door, facing it. Unlock it.
    action_sequence.append("UNLOCK")
    # print(f"Unlocked DOOR. Final state: pos={agent_pos}, dir={agent_dir}")

    return action_sequence

if __name__ == "__main__":
    # Example grid and direction
    grid = [
["WALL","WALL","WALL","WALL","WALL","WALL","WALL","WALL","WALL","WALL","WALL"],
["WALL","","","","KEY","WALL","","","","","WALL"],
["WALL","","","AGENT","","WALL","","","","","WALL"],
["WALL","","","","","DOOR","","","","","WALL"],
["WALL","","","","","WALL","","","","","WALL"],
["WALL","WALL","WALL","WALL","WALL","WALL","WALL","WALL","WALL","WALL","WALL"]
    ]
    direction = "RIGHT"
    
    actions = solve(grid, direction)
    print("Actions to solve the game:", actions)